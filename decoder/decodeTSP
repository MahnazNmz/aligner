#!/usr/bin/env python
import optparse
import sys
import models
import numpy
import math
from collections import namedtuple

optparser = optparse.OptionParser()
optparser.add_option("-i", "--input", dest="input", default="data/input", help="File containing sentences to translate (default=data/input)")
optparser.add_option("-t", "--translation-model", dest="tm", default="data/tm", help="File containing translation model (default=data/tm)")
optparser.add_option("-l", "--language-model", dest="lm", default="data/lm", help="File containing ARPA-format language model (default=data/lm)")
optparser.add_option("-n", "--num_sentences", dest="num_sents", default=sys.maxint, type="int", help="Number of sentences to decode (default=no limit)")
optparser.add_option("-k", "--translations-per-phrase", dest="k", default=5, type="int", help="Limit on number of translations to consider per phrase (default=1)")
optparser.add_option("-s", "--stack-size", dest="s", default=100, type="int", help="Maximum stack size (default=1)")
optparser.add_option("-v", "--verbose", dest="verbose", action="store_true", default=False,  help="Verbose mode (default=off)")
opts = optparser.parse_args()[0]

tm = models.TM(opts.tm, opts.k)
lm = models.LM(opts.lm)
french = [tuple(line.strip().split()) for line in open(opts.input).readlines()[:opts.num_sents]]

def edgeCosts(v1, v2):
  if v1[1] == v2[1]:
    return 0
  else:.
    prob = tm[v2[1][1]].logprob
    lm_state = v1[1][1].english.split()

    for word in phrase.english.split():
      (lm_state, word_logprob) = lm.score(lm_state, word)
      logprob += word_logprob
    logprob += lm.end(lm_state) if i + (k - j) == len(f)  else 0.0
    logprob += -math.log(abs(h.phrase_index[1] - j)**0.5)

for f in french:
  vertices = {}  
  for start in range(len(f)):
    if f[start:start+2] in tm:
      left = true
      for phrase in tm[f[start:start+2]]:
        for word in f[start:start+2]:
          vertices[(word, (f[start:start+2], phrase),left)] = []
          #only two values, left becomes false for right value
          left = false
  for vertex in vertices.iterkeys():
    for adj in vertices.iterkeys():
      if not vertex[2] == adj[2]:
        if vertex[2] and vertex[1] == adj[1]:
          vertices[vertex].append(adj)
        else if not vertex[2]
          vertices[vertex].append(adj)

        



      





